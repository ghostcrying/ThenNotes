# PBKDF2

### Salt

- 什么是加盐?
  - 在密码学中，通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“**加盐**”。

- 为什么要加盐?

  - 过去我们为了防止因为数据库的泄露，而造成里面保存的用户名和密码的泄露。通常的做法是不存储明文密码，而是存储加密后的密码，比如存储通过 **MD5** 或 **SHA1** 加密后的密文。然而这种方式也是不安全的，只要枚举出所有的常用密码，做成一个索引表，就可以推出来原始密码，这张索引表也被叫做“**彩虹表**”（之前 **csdn** **600** 万用户明文密码就是一个很好的素材）。

  - 而通过加盐，我们在原始密码加上特定的随机字符串字符串，同时再灵活地调整插入的位置。这样即便数据库泄露了，由于密码都是加了 **Salt** 之后的散列，使用数据字典已经无法直接匹配，明文密码被破解出来的概率也大大降低。即使是暴力破解也需要付出很大的时间成本。

- 加盐的注意事项

  - 盐值不要太短。为了使攻击者无法构造包含所有可能盐值的查询表，盐值越长越好（至少为 **8** 字节）。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如 **SHA256** 算法的输出是 **256bits**（**32 bytes**)，那么盐值也至少应该是 **32** 个随机字节。

  - 盐要求的是随机性，采用固定盐在数学上等于没加盐。比如我们对用户密码加密，每个用户的盐都应该是不同的

- **注意：不建议将用户名作为盐值**。
  - 尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。



### PBKDF2

> - **PBKDF2**（**Password-Based Key Derivation Function**）是一个用来导出密钥的函数，常用于生成加密的密码。
> - 它的基本原理是通过一个伪随机函数（例如 **HMAC** 函数），把明文和一个盐值作为输入参数，然后重复进行运算，并最终产生密钥。
> - 如果重复的次数足够大，破解的成本就会变得很高。而盐值的添加也会增加“彩虹表”攻击的难度。



### Example

> - **password**：用来生成密钥的原始密码
> - **salt**：加密用的盐值
> - **iterations**：重复计算的次数。默认值：**4096**
> - **keyLength**：期望得到的密钥的长度。默认值：不指定
> - **variant**：加密使用的伪随机函数。默认值：**sha256**

```
let password = "hangge2017"
let salt = "Ut3Opm78U76VbwoP4Vx6UdfN234Esaz9"

// 默认加密
let pbkdf2 = try! PKCS5.PBKDF2(password: password.bytes, salt: salt.bytes).calculate()
// 99ac74daf95a383efd15386572e385f603b99525ad0ef2f80c5fd552e623e351

// 指定秘钥长度
let pbkdf2 = try! PKCS5.PBKDF2(password: password.bytes, salt: salt.bytes,
                               keyLength: 4).calculate()
// 99ac74da

// 指定MD5加盐
let pbkdf2 = try! PKCS5.PBKDF2(password: password.bytes, salt: salt.bytes, iterations: 4096,
                               variant: .md5).calculate()
// 722d04f15c978bd92b3aa88bccbcd82d
```

